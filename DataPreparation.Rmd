---
title: "TCR phospho-signalling upon antibody-based stimulation"
author: "Marie Locard-Paulet"
date: '`r date()`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(venneuler)
library(gplots)
```

# Aim of the analysis

The aim of the analysis is to identify phosphorylation sites that are regulated upon antibody-based TCR activation in primary T-cells. A global analysis of our proteomic/phosphoproteomic data sets should allow us to study phospho-signalling resulting from TCR activation in primary cells.

# Sample preparation and input files

## Cell stimulation

Romain Roncagalli performed cell isolation and stimulation 4 times (R1: 20141204, R3: 20150306, R4: 20150713, R5: 20151103) as follows:

Day 0:

1. Purified CD4+T cells (negative selection dynal, invitrogen cat: 114-15D) are activated in culture with 3 ug/ml of coated (O/N 4C or 4H 37C and wash 3X with PBS1X) anti-CD3 (2C11) + soluble anti-CD28 (1ug/ml). 4 ml/well of 0.625 10^6 cells/ml are distributed in 6 well plates. 
Use complete RPMI 
 
Day 2:

1. Harvest cells, wash and count 
2. Resuspend cells at 1 10^6 cells/ml with IL-2 (1/2000), and distribute them: 5ml/well (6 well plates)
 
Day 3:

Add 5 ml of complete medium with IL-2/ well
 
Day 4:

1. Wash cells 2X with 37 C RPMI SF, count  
2. 50 10^6 of cells are resuspended in 4 ml RPMI SF, pelleted and 10 ug of biotinylated anti-CD3 + 10 ug of biotinylated anti-CD4 were added on pellets. (for ab stimulation). 2X 50 10^6 were prepared for each condition.
3. Pellets are resuspended in 100 ul of  37C SF RPMI and incubated for 5 min at 37C
4. 28 ug (100 ul) of purified Streptavidin (SAV) for ab stimulation and incubated for different time points 37C
5. Stimulation was stopped by freezing tube in liquid nitrogen


## Sample preparation for MS analysis

### Peptide samples

After trypsin digestion, 5ug of each peptide sample was injected on the Q-Exactive plus for relative protein quantification.

### phospho-samples 

Carine Froment performed TiO2 enrichments, injected 3 to 4 times 2.5% of them (labelled "TiO2") and performed a phospho-tyrosine IP on the 90% remaining (injected in 3 to 4 technical replicates - corresponds to 22.5% of starting material). Samples were injected onto a Q-Exactive Plus for label-free MS relative quantification. The analysis was performed using Maxquant.


## Input files

The input files are all in the folder `RAW/`:

* `PeptideSamples/`: output protein table from the MaxQuant analysis of all peptide samples prior to TiO2 and phospho-tyrosine enrichment.
* `TiO2/`: output phosphosites tables from the MaxQuant analysis of 10% of the samples after TiO2 and before phospho-tyrosine enrichment. Each biological replicate was searched independently.
* `pYIP/`: output phosphosites tables from the MaxQuant analysis of the samples after TiO2 and phospho-tyrosine enrichment. Each biological replicate was searched independently.


```{r, eval = F}
files <- list.files("RAW/", pattern = ".txt", recursive = T, full.names = T)
files <- files[(grepl("TiO2", files) | grepl("pYIP", files)) & !grepl("peptides", files)]
lf <- lapply(files, read.delim, stringsAsFactors = F, sep = "\t", header = T)
names(lf) <- gsub("RAW//", "", files, fixed = T)
```

--------------------------------------------------------------------------------

# Multisites parsing

MaxQuant returns a table with one row per phosphorylation site. It returns the quantification values for the multiply phosphorylated site but does not map them to the corresponding pairs (or triplets). I use a script to identify the quantification values comming from the multiply phosphorylated peptides and match them.

I keep only the sites with a PEP value <= 0.01.

```{r, eval = F}
source("RFunctions/MultiPhosphoParsingMQ_20180817.R")

for (i in seq_along(lf)) {
  tab <- lf[[i]]
  tab <- tab[!grepl("CON_", tab$Protein) & !grepl("REV_", tab$Protein),]
  tab <- tab[(tab$PEP <= 0.01),]
  tab <- MultiPhosphoParsingMQ(tab)
  sitespos <- sapply(as.character(tab$phosphoSites), function(x) {
    strsplit(x, "_", fixed = T)[[1]][2]
  })
  tab$psiteGeneID <- paste0(tab$`Gene.names`, "_", sitespos)
  lf[[i]] <- tab
}
names(lf) <- sapply(names(lf), function(x) {
  substr(x, start = nchar("pYIP/Phospho (STY)Sites_ProFI-S4_p"), stop = nchar("pYIP/Phospho (STY)Sites_ProFI-S4_pYIP_R1"))
})
save(lf, file = "RData/01_ParsedTables.RData")
```

```{r}
load(file = "RData/01_ParsedTables.RData")
```

I create a list with for each phosphorylation site ID its ID with gene name (for figures) and the list of all the mono-phosphorylations it corresponds to.

```{r, eval = F}
vecID <- vector(mode = "list")
vecGeneID <- vector(mode = "list")
lMono <- vector(mode = "list")
for (i in seq_along(lf)) {
  vecID[[i]] <- lf[[i]]$phosphoSites
  vecGeneID[[i]] <- lf[[i]]$psiteGeneID
  vec <- sapply(as.character(lf[[i]]$phosphoSites), function(x) {
    strsplit(x, "_", fixed = T)[[1]][2]
  })
  vec <- lapply(seq_along(vec), function(x) {
    paste0(lf[[i]]$Accession[x], "_", strsplit(vec[x], "+", fixed = T)[[1]])
  })
  names(vec) <- vecID[[i]]
  lMono[[i]] <- vec
}
uID <- sort(unique(unlist(vecID)))
mappingID <- unlist(vecID)
vecGeneID <- unlist(vecGeneID)

psiteInfo <- vector(mode = "list")
i = 0
for (el in uID) {
  i = i + 1
  vec <- sapply(lMono, function(x) {
    unique(x[names(x) == el])
  })
  vec <- unique(unlist(vec))
  lel <- list("phosphoSites" = el, "GeneID" = unique(vecGeneID[vecID == el]), "MonoSites" = sort(vec))
  psiteInfo[[i]] <- lel
}
names(psiteInfo) <- uID
save(psiteInfo, file = "RData/02_psiteInfo.RData")
```

```{r}
load(file = "RData/02_psiteInfo.RData")
```

# Data normalisation using iRTs 

In order to correct for technical variation due to the instrument with spided-in synthetic peptides. I use their intensity to normalise the data. I use the run with the highest sum of intensities of all the iRTs as a reference. Then, I calculate a normalisation factor median from all the iRTs.

```{r}
files <- list.files("RAW/iRTNorm/", pattern = ".txt", recursive = T, full.names = T)
iRT <- lapply(files, read.delim, stringsAsFactors = F, sep = "\t", header = T)
names(iRT) <- gsub("RAW/iRTNorm/peptides_", "", files, fixed = T)
names(iRT) <- gsub(".txt", "", names(iRT), fixed = T)
rm(files)

for (i in seq_along(iRT)) {
  tab <- iRT[[i]]
  tab <- tab[grepl("Biognosys", tab$Proteins),]
  mat <- tab[,grepl("Intensity.", names(tab), fixed = T)]
  # boxplot(log2(mat), las = 2, main = names(iRT)[i])
  cv <- sapply(seq_len(nrow(tab)), function(x) {
    sd(mat[x,], na.rm = T)/mean(as.numeric(mat[x,]), na.rm = T)
  })
  # Keep only the iRTs with a CV < 50%:
  mat <- mat[cv < 0.5,]
  # I take as a reference the condition with the maximum sum of intensities of all the iRTs:
  sums <- colSums(mat)
  ref <- which(sums == max(sums, na.rm = T))
  ref <- mat[,ref]
  for (j in seq_len(ncol(mat))) {
    mat[,j] <- mat[,j] / ref
  }
  # Median of the normalisation factors:
  med <- sapply(seq_len(ncol(mat)), function(x) {
    median(as.numeric(mat[,x]), na.rm = T)
  })
  names(med) <- colnames(mat)
  iRT[[i]] <- med
}
```

```{r}
lf <- lf[order(names(lf))]
iRT <- iRT[order(names(iRT))]
for (i in seq_along(lf)) {
  tab <- lf[[i]]
  mat <- tab[,grepl("Intensity.", names(tab), fixed = T) & grepl("_Parsed", names(tab), fixed = T)]
  mat[mat == 0] <- NA
  mat <- apply(mat, 2, as.numeric)
  norm <- iRT[[i]]
  for (j in seq_len(ncol(mat))) {
    mat[,j] <- mat[,j]/norm[names(norm) == gsub("_Parsed", "", colnames(mat)[j])]
  }
  colnames(mat) <- gsub("_Parsed", "_iRTNorm", colnames(mat))
  tab <- cbind(tab, mat)
  lf[[i]] <- tab
}
rm(iRT)
```

# Data cleaning

For the replicate 1 (R1) of the TiO2, we noticed that the injection 1 were not ran in optimum conditions. There are more than 50% missing values in these runs. We remove them.

I also remove the R1_S120.Inj3bis that has a lower intensity than the others, which would impact the statistical analysis.

```{r, echo = F}
lf$TiO2_R1 <- lf$TiO2_R1[,!grepl(".Inj1_iRTNorm", names(lf$TiO2_R1))]
lf$TiO2_R1 <- lf$TiO2_R1[,!grepl("S120.Inj3bis_iRTNorm", names(lf$TiO2_R1))]
```

--------------------------------------------------------------------------------

# Number of sites

```{r}
n <- length(unique(names(psiteInfo)))
vec <- vector(mode = "character")
for (el in psiteInfo) {
  vec <- c(vec, el$MonoSites)
}
vec <- unique(vec)
```

There are `r n` unique sites or combination of sites (from multiply phosphorylated peptides) in the whole data set. These correspond to `r length(vec)` individual phosphorylation sites.

```{r}
par(mar = c(1, 1, 4, 1))
npprot <- sapply(lf, function(x) length(unique(x$Accession)))
npsites <- sapply(lf, function(x) length(unique(x$phosphoSite)))
lvenn <- lapply(lf, function(x) unique(x$phosphoSite))
# Draw venn diagrams:
## pYIP:
l <- lvenn[grepl("pYIP", names(lvenn))]
vec <-  sapply(l, length)
intAB <- length(intersect(l[[1]], l[[2]]))
intBC <- length(intersect(l[[3]], l[[2]]))
intAC <- length(intersect(l[[3]], l[[1]]))
intABC <- length(intersect(intersect(l[[3]], l[[2]]), l[[1]]))
v1 <- venneuler(c(A = as.numeric(vec[1]), B = as.numeric(vec[2]), C = as.numeric(vec[3]), "A&B" = intAB, "B&C" = intBC, "A&C" = intAC, "A&B&C" = intABC))

plot(v1)
title("pYIP\nRep 1, 4, 5")
venn(l)



## TiO2:
l <- lvenn[grepl("TiO2", names(lvenn))]
vec <-  sapply(l, length)
intAB <- length(intersect(l[[1]], l[[2]]))
intBC <- length(intersect(l[[3]], l[[2]]))
intAC <- length(intersect(l[[3]], l[[1]]))
intAD <- length(intersect(l[[4]], l[[1]]))
intBD <- length(intersect(l[[4]], l[[2]]))
intCD <- length(intersect(l[[4]], l[[3]]))
intABC <- length(intersect(intersect(l[[3]], l[[2]]), l[[1]]))
intABD <- length(intersect(intersect(l[[4]], l[[2]]), l[[1]]))
intACD <- length(intersect(intersect(l[[3]], l[[4]]), l[[1]]))
intABCD <- length(intersect(intersect(intersect(l[[3]], l[[4]]), l[[1]]), l[[2]]))
v2 <- venneuler(c(A = as.numeric(vec[1]), B = as.numeric(vec[2]), C = as.numeric(vec[3]), D = as.numeric(vec[4]), "A&B" = intAB, "B&C" = intBC, "A&C" = intAC, "A&D" = intAD, "D&C" = intCD, "D&B" = intBD, "A&B&C" = intABC, "A&B&D" = intABD, "A&C&D" = intACD, "A&B&C&D" = intABCD))

plot(v2)
title("TiO2\nRep 1, 3, 4, 5")

venn(l)

pdf("Figures/Venns.pdf", useDingbats=FALSE, 11.69, 8.27)
plot(v1)
title("pYIP\nRep 1, 4, 5")
plot(v2)
title("TiO2\nRep 1, 3, 4, 5")
dev.off()
```

## For figure 1

Number of phosphorylation sites identified.

```{r}
# Number of amino acids:
laa <- lapply(lf, function(x) {
  lapply(x$phosphoSites, function(y) {
    psiteInfo[names(psiteInfo) == y][[1]]$MonoSites
  })
})
laaID <- lapply(laa, function(x) {
  unlist(x)
})
  
laa <- lapply(laaID, function(x) {
  as.character(
    sapply(x, function(y) {
      gsub("[1234567890]", "", strsplit(y, "_", fixed = T)[[1]][2])
    })
  )
})
laa <- sapply(laa, function(x) {
  gsub(";", "", x, fixed = T)
})
aa <- sapply(laa, table)
name <- sapply(laa, function(x) names(table(x)))


# Cumulative:
## pYIP:
aatot <- unique(c(laaID[[1]], laaID[[2]]))
vec <- sapply(aatot, function(x) {
  psiteInfo[names(psiteInfo) == x][[1]]$MonoSites
})
vec <- sapply(vec, function(x) {
  gsub("[1234567890]", "", strsplit(x, "_", fixed = T)[[1]][2])
})
vec <- sapply(vec, function(x) {
  gsub(";", "", x, fixed = T)
})
aa2 <- cbind("pYIP_R1" = aa[,1], "pYIP_R3"=table(vec))

aatot <- unique(c(laaID[[1]], laaID[[2]], laaID[[3]]))
vec <- sapply(aatot, function(x) {
  psiteInfo[names(psiteInfo) == x][[1]]$MonoSites
})
vec <- sapply(vec, function(x) {
  gsub("[1234567890]", "", strsplit(x, "_", fixed = T)[[1]][2])
})
vec <- sapply(vec, function(x) {
  gsub(";", "", x, fixed = T)
})
aa2 <- cbind(aa2, "pYIP_R5"=table(vec))

## TiO2:
aatot <- unique(c(laaID[[4]], laaID[[5]]))
vec <- sapply(aatot, function(x) {
  psiteInfo[names(psiteInfo) == x][[1]]$MonoSites
})
vec <- sapply(vec, function(x) {
  gsub("[1234567890]", "", strsplit(x, "_", fixed = T)[[1]][2])
})
vec <- sapply(vec, function(x) {
  gsub(";", "", x, fixed = T)
})
aa1 <- cbind("TiO2_R1" = aa[,4], "TiO2_R3"=table(vec))

aatot <- unique(c(laaID[[4]], laaID[[5]], laaID[[6]]))
vec <- sapply(aatot, function(x) {
  psiteInfo[names(psiteInfo) == x][[1]]$MonoSites
})
vec <- sapply(vec, function(x) {
  gsub("[1234567890]", "", strsplit(x, "_", fixed = T)[[1]][2])
})
vec <- sapply(vec, function(x) {
  gsub(";", "", x, fixed = T)
})
aa1 <- cbind(aa1, "TiO2_R4"=table(vec))

aatot <- unique(c(laaID[[4]], laaID[[5]], laaID[[6]], laaID[[7]]))
vec <- sapply(aatot, function(x) {
  psiteInfo[names(psiteInfo) == x][[1]]$MonoSites
})
vec <- sapply(vec, function(x) {
  gsub("[1234567890]", "", strsplit(x, "_", fixed = T)[[1]][2])
})
vec <- sapply(vec, function(x) {
  gsub(";", "", x, fixed = T)
})
aa1 <- cbind(aa1, "TiO2_R5"=table(vec))

laatables <- list("TiO2" = aa1, "pYIP"= aa2)

for (i in seq_along(laatables)) {
  tab <- laatables[[i]]
  tab <- rbind(tab, colSums(tab))
  row.names(tab)[nrow(tab)] <- "total"
  laatables[[i]] <- tab
}

print(tab)

aaNotRef <- sapply(lf, function(x) table(x$Amino.acid[x$psiteID %in% psitesNotInPhosphositePlus0]))
aatot <- rbind(lf[[1]][,c("psiteID", "Amino.acid")], lf[[2]][,c("psiteID", "Amino.acid")])
aatot <- aatot[!duplicated(aatot$psiteID),]
aatot <- aatot[aatot$psiteID %in% psitesNotInPhosphositePlus0,]
aaNotRef2 <- cbind("R1" = aaNotRef[,1], "R3"=table(aatot$Amino.acid))
aatot <- rbind(lf[[1]][,c("psiteID", "Amino.acid")], lf[[2]][,c("psiteID", "Amino.acid")], lf[[3]][,c("psiteID", "Amino.acid")])
aatot <- aatot[!duplicated(aatot$psiteID),]
aatot <- aatot[aatot$psiteID %in% psitesNotInPhosphositePlus0,]
aaNotRef2 <- cbind(aaNotRef2, "R4"=table(aatot$Amino.acid))
aatot <- rbind(lf[[1]][,c("psiteID", "Amino.acid")], lf[[2]][,c("psiteID", "Amino.acid")], lf[[3]][,c("psiteID", "Amino.acid")], lf[[4]][,c("psiteID", "Amino.acid")])
aatot <- aatot[!duplicated(aatot$psiteID),]
aatot <- aatot[aatot$psiteID %in% psitesNotInPhosphositePlus0,]
aaNotRef2 <- cbind(aaNotRef2, "R5"=table(aatot$Amino.acid))
aatot <- rbind(lf[[1]][,c("psiteID", "Amino.acid")], lf[[2]][,c("psiteID", "Amino.acid")], lf[[3]][,c("psiteID", "Amino.acid")], lf[[4]][,c("psiteID", "Amino.acid")])
aatot <- aatot[!duplicated(aatot$psiteID),]
aatot <- aatot[aatot$psiteID %in% psitesNotInPhosphositePlus0,]
aaNotRef2 <- cbind(aaNotRef2, "total"=length(aatot$Amino.acid))

numtotSnotref <- length(unique(aatot$psiteID[aatot$Amino.acid=="S"]))
numtotTnotref <- length(unique(aatot$psiteID[aatot$Amino.acid=="T"]))
numtotYnotref <- length(unique(aatot$psiteID[aatot$Amino.acid=="Y"]))
```
--------------------------------------------------------------------------------

```{r}
sessionInfo()
```